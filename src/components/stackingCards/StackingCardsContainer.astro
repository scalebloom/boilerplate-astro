<div class="stacking-cards-container">
  <slot />
</div>

<script>
  /**
   * Mobile UX Issue: When card content is tall, fixed sticky positions cause the next card
   * to overlay before the current card's image is fully visible.
   *
   * Solution: Conditionally disable stacking on mobile when any card exceeds viewport height threshold.
   * This preserves the effect for short cards while preventing UX issues with tall cards.
   * All-or-nothing per group to avoid mixed behavior.
   *
   * Failed alternatives:
   * - Dynamic positions: Cumulative spacing pushed later cards too far down
   */
  (() => {
    // Initialize only when cards are near viewport
    const container = document.querySelector(".stacking-cards-container");
    if (!container) return;

    const observer = new IntersectionObserver(
      (entries) => {
        if (!entries[0].isIntersecting) return;

        // Disconnect observer - we only need to initialize once
        observer.disconnect();

        // Initialize stacking cards behavior
        const cards = document.querySelectorAll<HTMLElement>(".stacking-card");

        const shouldEnableStacking = () => {
          const isMobile = window.innerWidth < 768;

          // Always enable on desktop
          if (!isMobile) return true;

          // On mobile, check if any card is too tall
          const viewportHeight = window.innerHeight;
          const threshold = viewportHeight * 0.9; // 90vh

          for (const card of cards) {
            if (card.offsetHeight > threshold) {
              return false; // Disable stacking if any card too tall
            }
          }

          return true; // Enable stacking if all cards are short enough
        };

        const applyStickyPositioning = () => {
          const enableStacking = shouldEnableStacking();

          cards.forEach((card, index) => {
            if (enableStacking) {
              card.style.position = "sticky";
              card.style.top = `calc(var(--header-height) + clamp(2rem, 3vw, 3.5rem) + ${index} * clamp(0.5rem, 1vw, 1rem))`;
              card.style.transition = "transform 0.3s ease-out";
              card.style.transformOrigin = "top center";
            } else {
              // Remove sticky positioning
              card.style.position = "static";
              card.style.top = "";
              card.style.transform = "scale(1)"; // Reset any scaling
            }
          });

          return enableStacking;
        };

        let isStackingEnabled = applyStickyPositioning();

        const updateCardScales = () => {
          // Skip scale updates if stacking is disabled
          if (!isStackingEnabled) return;
          cards.forEach((card, index) => {
            const cardRect = card.getBoundingClientRect();
            const cardTop = parseFloat(getComputedStyle(card).top);

            // Calculate if this card has reached its sticky position
            const hasReachedTop = cardRect.top <= cardTop;

            if (!hasReachedTop) {
              // Card hasn't reached the top yet, full scale
              card.style.transform = "scale(1)";
              return;
            }

            // Check if the next card is approaching
            if (index < cards.length - 1) {
              const nextCard = cards[index + 1];
              const nextCardRect = nextCard.getBoundingClientRect();
              const nextCardTop = parseFloat(getComputedStyle(nextCard).top);

              // Calculate how close the next card is to its sticky position
              const distanceUntilNextSticks = nextCardRect.top - nextCardTop;

              // Start scaling when next card is within a certain distance
              // Make scale range responsive: smaller on mobile, larger on desktop
              const scaleRange = window.innerWidth < 768 ? 200 : 500;

              // Calculate final scale for this card based on its index
              // Earlier cards scale down more (further away), later cards scale down less (closer to user)
              const scaleDecrement = 0.03; // Amount to scale down per card
              const cardsFromEnd = cards.length - 1 - index; // How many cards are after this one
              const minScale = 1 - scaleDecrement * (cardsFromEnd + 1);

              if (distanceUntilNextSticks <= scaleRange) {
                // Scale from 1.0 down to minScale as next card approaches
                const progress = Math.max(
                  0,
                  distanceUntilNextSticks / scaleRange,
                );
                const scale = minScale + progress * (1 - minScale);
                card.style.transform = `scale(${scale})`;
              } else {
                // Next card is far away, keep at full scale
                card.style.transform = "scale(1)";
              }
            } else {
              // Last card, no need to scale down
              card.style.transform = "scale(1)";
            }
          });
        };

        // Update on scroll
        window.addEventListener("scroll", updateCardScales, { passive: true });

        // Recalculate stacking on resize (e.g., device rotation)
        let resizeTimeout: ReturnType<typeof setTimeout>;
        window.addEventListener("resize", () => {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(() => {
            isStackingEnabled = applyStickyPositioning();
            updateCardScales();
          }, 150);
        });

        // Initial update
        updateCardScales();
      },
      { rootMargin: "200px" }, // Start loading 200px before visible
    );

    observer.observe(container);
  })();
</script>
